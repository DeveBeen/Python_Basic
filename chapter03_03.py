# Chapter03-3
# 파이썬 리스트
# 자료구조에서 중요하며, 다른 언어에선 배열이라 한다.
# 리스트 자료형은 순서,중복,수정,삭제가 모두 가능한 유일한 자료형이다.

# 리스트 선언
a = [] # 기본적인 리스트 선언이다.
b = list() # 위와 같은 빈 리스트를 선언하는 방식이다.
c = [70, 75, 80, 85] # 0번 ~ 3번으로 4개의 원소로 선언되는 리스트다.
print(len(c)) # str(문자형) 자료형에서 사용한 len함수가 list에서도 적용된다. (List에선 원소의 개수가 나온다.)

d = [1000, 10000, 'Ace', 'Base', 'Captine'] # 이처럼 서로 다른 자료형이여도 하나의 리스트 안에 넣을 수 있다.
e = [1000, 10000, ['Ace', 'Base', 'Captine']] # 이처럼 리스트 안에 리스트도 넣을 수 있다. 이는 0번이 1000, 1번이 10000, 3번이 리스트인 리스트인 것이다.
f = [21.42, 'foobar', 3, 4, False, 3.14159] # 실수형, 정수형, 문자형, 불린형 등 많은 자료형을 담을 수 있다.

# 인덱싱 : 내가 원하는 데이터를 꺼내오는 작업
print('d - ', type(d), d) # 항상 해왔듯이 변수 d에 대하여 Class는 list이고, d의 원소가 차례로 출력된다.
print('d - ', d[1]) # d[N]은 N번 원소를 출력하는 것이다.
print('d - ', d[0] + d[1] + d[1]) # 리스트 호출 방식을 사용하여 원소끼리 계산도 할 수 있다.
print('d - ', d[-1]) # 문자열과 같은 방식으로 '-'호출은 우측 원소부터 호출된다.
print('e - ', e[-1][1]) # 변수 e의 [-1]원소는 리스트이다. 그 리스트의 [1]을 호출했으므로, 'Base'가 출력된다. 추가로 type class는 str(문자열)이다.
print('e - ', list(e[-1][1])) # 형 변환을 통해서 'Base' 문자열을 List로 형 변환이 가능하다. 따라서 이는 ['B', 'a', 's', 'e']

# 슬라이싱
print('d - ', d[0:3]) # 리스트도 문자열 슬라이싱하는 것과 똑같이 출력된다. 다른 방식도 다 동일하다.

# 리스트 연산 : 리스트 + 리스트 = 리스트
print('c + d', c + d) # 이 또한 문자형처럼 c 뒤에 d가 이어져서 출력되어 하나의 리스트가 되는 것을 알 수 있다.
print('c * 3', c * 3) # 문자열 계산 때, 곱 연산은 그 단어를 곱한 정수만큼 출력했듯, 리스트도 그만큼을 반복해서 하나의 리스트로 다시 묶는다.
print("'Test' + c[0] : ", 'Test' + str(c[0])) # Type이 다르면 이와 같이 형변환을 사용하여 응용해도 된다.

# 값 비교
print(c == c[:3] + c[3:]) # 둘 다 따로 출력해보면 같음을 알 수 있지만, 이렇게 출력하면 하나의 원소도 빠짐없이 출력한 것이므로 이는 True가 나온다.

# Identity(id)
temp = c # temp 변수에다 c 값을 할당
print(temp, c)
print(id(temp))
print(id(c)) # 출력시 둘 다 id가 같음을 알 수 있다. 따라서 이는 리스트도 파이썬이 효율적으로 사용하기 위해 같은 id로 할당하는 것을 알 수 있다.

# 리스트 수정
c[0] = 4
print('c - ', c) # 위에서 0번째 원소에 0을 재선언했다. 그리고 이를 출력하였더니, 원래 0번째 원소였던 70이 4로 수정되어 출력된 것을 알 수 있다.
c[1:2] = ['a', 'b', 'c']
print('c - ', c) # 슬라이싱 된 c[1:2]는 c[1]이므로 1번째 원소인 75 대신에 'a','b','c'가 들어가는데, 이때 리스트가 통체로 안들어가고 원소만 들어가는 이유는 리스트 연산이 자동으로 되어 하나의 리스트로 수정되었기 때문이다.
c[1:2] = [['a', 'b', 'c']]
print('c - ', c) # 만약 리스트안에 리스트를 넣고 싶으면 리스트를 두 번 사용하여 위처럼 선언하면 된다.
c[1] = ['a', 'b', 'c']
print('c - ', c) # 슬라이싱 방식이 아닌 원소를 인덱싱하여 리스트를 수정하면, 리스트를 한 번만 사용해도 리스트 안에 리스트가 들어간다.
c[1:3] = []
print('c - ', c) # 1번, 2번 원소를 인덱싱하여 빈 리스트로 재 선언하였으므로, ['a', 'b', 'c']와 'b'는 사라졌다.

# 리스트 삭제
del c[2]
print('c - ', c) # del을 사용하여 리스트의 원소를 삭제 할 수도 있다. 여기에선 2번째 원소를 제거 했으므로, 80이 증발.

# 리스트 함수
a = [5, 2, 3, 1, 4]
print('a - ', a)

a.append(10)
print('a - ', a) # .append() : 영문 뜻 그대로 리스트 마지막에 괄호 안에 입력한 값을 추가 시켜준다.
a.sort()
print('a - ', a) # .sort() : 리스트안 원소를 크기 순으로 정령해준다. 작은 수 부터 큰 수.
a.reverse()
print('a - ', a) # .reverse() : 말 그대로 원소 순서를 반대로 출력해준다.
print('a - ', a.index(3)) # .index() : 위에서 인덱스를 설명했듯이, 괄호안에 입력한 원소를 가져온다.
a.insert(2, 7)
print('a - ', a) # .insert(a, b) : a번째에 b를 넣는 함수이다.
a.reverse()
# del a[6] -> 이처럼 6번째 원소를 삭제하라는 함수는 너무 비효율적이다. (예를 들어서 원소가 10만개가 있을 시에 원하는 값을 삭제하려면 눈으로 순서를 세어보기엔 비효율)
# print('a - ', a)
a.remove(10) # .remove() : 괄호안에 작성한 값을 리스트에서 삭제해주는 함수.
print('a - ', a)
print('a - ', a.pop()) # .pop() : 리스트의 마지막 원소를 추출하고, 그 원소를 리스트에서 삭제해주는 함수.
print('a - ', a) # 이처럼 마지막 원소인 '5'가 추출되고 리스트에서 삭제 되어 출력된 것을 알 수 있다.
print('a - ', a.count(4)) # .count() : 괄호안에 값이 리스트에 몇 개 있는지 카운트 해주는 함수.
ex [8, 9]
a.expend(ex) # .expend() : 괄호안에 값을 선언한 리스트에 이어 붙이는 함수.
print('a - ', a)

# 삭제 : remove, pop, del

# 반복문 활용 : pop인 연속되어 리스트의 값을 모두 빼줌을 알 수 있다.
while a:
    data = a.pop()
    print(data)
